<!DOCTYPE html>
<html lang='en'>

<head>
  <title>GBG CAR</title>
</head>

<body>
  <p>Use the buttons below to turn the car's joystick on and off.</p>
  <button onclick='activate();' style='font-size: 100px;'>GO</button>
  <button onclick='fetch("/deactivate");' style='font-size: 200px; float: right;'>STOP</button>
  <br>
  <div style="font-size: 50px;">status:</div>
  <div id="status" style="font-size: 50px;">loading</div>
  <br>
  <br>
  <div style="font-size: x-large;">remote override mode</div>
  <input type="radio" id="ctl-car" name="remote-mode" value="0" checked onclick='sendRemoteMode(0);' />
  <label for="ctl-car" style="font-size: x-large;">car has control</label>
  <br>
  <input type="radio" id="ctl-remote" name="remote-mode" value="1" onclick='sendRemoteMode(1);' />
  <label for="ctl-remote" style="font-size: x-large;">remote has control</label>
  <br>
  <br>
  <input type="checkbox" id='timeout' onclick='sendTimeout();'></input>
  <label for="timeout" style="font-size: larger;">deactivate if signal lost</label>

  <div id="joyDiv"
    style="width:500px;height:500px;margin-left:100%;margin-right:200px;margin-bottom:20px;margin-top:20px;float:right;">
    <canvas id="ds-canvas" width="500" height="500"></canvas>
  </div>

  <details>
    <summary> <b>Edit Settings</b> <br> &#9888; Don't edit settings with a kid in the car. Editing settings can cause
      the car to move. </summary>
    <div>
      <button onclick="loadSettings();" style="font-size: large;">Load Settings</button>
      <button onclick="saveSettings();" style="font-size: large;">Save Settings</button>
      <table id="car-settings">
      </table>
    </div>

</body>
<script>
  /*comments must be like this never with two slashes*/
  function settingsChange(name, value) {
    fetch("/setSetting?setData=" + name + ":" + value + ",");
  }

  function saveSettings() {
    fetch('/setSetting?setData="SAVE,"');
  }

  async function loadSettings() {
    var list = document.getElementById("car-settings");
    list.innerHTML = "";
    response = await fetch('/settings');
    settings = await response.json();
    for (const setting in settings) {
      if (setting == "current settings, version:") {
        continue;
      }
      var row = document.createElement("tr");
      var name = document.createElement("td");
      name.innerHTML = setting;
      row.appendChild(name);
      var valElem = document.createElement("td");
      if (settings[setting] == true || settings[setting] == false) {
        valElem.innerHTML = '<input type="checkbox" ' + (settings[setting] == "true" ? "checked" : "") + ' onchange="settingsChange(\"' + setting + '\", this.checked);"/>';
      } else {
        valElem.innerHTML = '<input type="text" maxlength="7" inputmode="decimal" value="' + settings[setting] + '" onchange="settingsChange(\"' + setting + '\", this.value)"/>';
      }
      row.appendChild(valElem);
      list.appendChild(row);
    }
  }

  class DSItemJoystick {
    /*inspired by github.com/RCMgames/RCMv3*/
    constructor(_dsCanvas) {
      this.dsCanvas = _dsCanvas;
      this.radius = 50;

      this.joyx = 0;
      this.joyy = 0;

      this.mousePressed = false;

      this.onMouseDownBound = this.onMouseDown.bind(this);
      this.onMouseUpBound = this.onMouseUp.bind(this);
      this.onMouseMoveBound = this.onMouseMove.bind(this);
      this.onTouchStartBound = this.onTouchStart.bind(this);
      this.onTouchEndBound = this.onTouchEnd.bind(this);
      this.onTouchMoveBound = this.onTouchMove.bind(this);

      document.addEventListener('mousedown', this.onMouseDownBound);
      document.addEventListener('mouseup', this.onMouseUpBound);
      document.addEventListener('mousemove', this.onMouseMoveBound);
      document.addEventListener('touchstart', this.onTouchStartBound);
      document.addEventListener('touchend', this.onTouchEndBound);
      document.addEventListener('touchmove', this.onTouchMoveBound, { passive: false });

      this.draw();
    }

    onMouseDown(event) {
      const rect = this.dsCanvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      if (mouseX >= 0 && mouseX <= this.dsCanvas.width && mouseY >= 0 && mouseY <= this.dsCanvas.height) {
        this.offsetX = mouseX;
        this.offsetY = mouseY;
        this.mousePressed = true;
        this.onMove(event.clientX, event.clientY);
        this.draw();
      }
    }
    onTouchStart(event) {
      const rect = this.dsCanvas.getBoundingClientRect();
      for (let i = 0; i < event.touches.length; i++) {
        const touch = event.touches[i];
        const mouseX = touch.clientX - rect.left;
        const mouseY = touch.clientY - rect.top;
        if (mouseX >= 0 && mouseX <= this.dsCanvas.width && mouseY >= 0 && mouseY <= this.dsCanvas.height) {
          this.offsetX = mouseX;
          this.offsetY = mouseY;
          this.mousePressed = true;
          this.activeTouchId = touch.identifier;
          this.onMove(touch.clientX, touch.clientY);
          this.draw();
        }
      }
    }
    onMouseUp() {
      this.mousePressed = false;
      this.draw();
    }
    onMouseMove(event) {
      this.onMove(event.clientX, event.clientY);
    }
    onMove(x, y) {
      if (this.mousePressed) {
        const rect = this.dsCanvas.getBoundingClientRect();
        this.joyx = (x - rect.left - this.dsCanvas.width / 2) / (this.dsCanvas.width / 2 - this.radius);
        this.joyy = -(y - rect.top - this.dsCanvas.height / 2) / (this.dsCanvas.height / 2 - this.radius);
        if (this.joyx > 1) this.joyx = 1;
        if (this.joyx < -1) this.joyx = -1;
        if (this.joyy > 1) this.joyy = 1;
        if (this.joyy < -1) this.joyy = -1;
        this.draw();
      }
    }
    onTouchEnd(event) {
      for (let i = 0; i < event.changedTouches.length; i++) {
        const touch = event.changedTouches[i];
        if (touch.identifier == this.activeTouchId) {
          this.mousePressed = false;
          this.activeTouchId = null;
          this.draw();
          break;
        }
      }
    }
    onTouchMove(event) {
      event.preventDefault();
      for (let i = 0; i < event.touches.length; i++) {
        const touch = event.touches[i];
        if (touch.identifier == this.activeTouchId) {
          this.onMove(touch.clientX, touch.clientY);
          break;
        }
      }
    }

    draw() {
      const ctx = this.dsCanvas.getContext('2d');
      ctx.beginPath();

      ctx.fillStyle = "#00AA00";

      ctx.roundRect(0, 0, this.dsCanvas.width, this.dsCanvas.height, [this.radius]);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = 'white';
      ctx.arc(this.dsCanvas.width / 2 + this.joyx * (this.dsCanvas.width / 2 - this.radius), this.dsCanvas.height / 2 - this.joyy * (this.dsCanvas.height / 2 - this.radius), this.radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    run() {
      if (!this.mousePressed) {
        this.joyx = 0;
        this.joyy = 0;
      }
      this.draw();
    }

    GetX() {
      return Math.round(this.joyx * 100) / 100;
    }

    GetY() {
      return Math.round(this.joyy * 100) / 100;
    }

  }

  var joystick = new DSItemJoystick(document.getElementById("ds-canvas"));

  fetch('/key').then(response => response.text()).then(data => {
    key = data;
  });
  setInterval(loop, 250);

  async function loop() {
    joystick.run();
    var remoteData = "?fb=" + joystick.GetY() + "&lr=" + joystick.GetX() + "&key=" + key;
    let errorTimeout;
    let abortcontroller = new AbortController();
    errorTimeout = setTimeout(() => {
      abortcontroller.abort("timeout");
    }, 200);

    try {
      var fetched = await fetch('/status' + remoteData, { signal: abortcontroller.signal });
      fetchedResponse = await fetched.json();

      let radios = document.getElementsByName("remote-mode");
      let value = parseInt(fetchedResponse["m"]);

      for (let i = 0, length = radios.length; i < length; i++) {
        radios[i].checked = parseInt(radios[i].value) === value;
      }

      if (value === 0) {/*modes that give a choice about deactivate when timeout*/
        document.getElementById("timeout").disabled = false;
      } else {
        document.getElementById("timeout").disabled = true;
      }

      document.getElementById("timeout").checked = fetchedResponse["d"] == 1;

      if (fetchedResponse["j"] == 1) {
        document.getElementById("status").innerHTML = (fetchedResponse["a"] == 1 ? "on" : "off");
      } else {
        document.getElementById("status").innerHTML = "center car joystick to start car";
      }

      if (fetchedResponse["k"] != key) {
        document.getElementById("status").innerHTML = "reload page";
      }
    } catch (e) {
      document.getElementById("status").innerHTML = "Disconnected";
    }
    clearTimeout(errorTimeout);
  }

  function sendTimeout() {
    if (document.getElementById("timeout").checked) {
      fetch("/timeoutOn?key=" + key);
    } else {
      fetch("/timeoutOff?key=" + key);
    }
  }

  function sendRemoteMode(mode) {
    fetch("/remoteMode?mode=" + mode + "&key=" + key);
  }

  function activate() {
    fetch("/activate?key=" + key);
  }

</script>

</html>